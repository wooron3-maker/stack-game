<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>３目カード並べ</title>
    <style>
        :root {
            --red-color: #d32f2f;
            --black-color: #212121;
            --bg-color: #f8f9fa;
            --board-bg: #555;
            --highlight-movable: #29b6f6;
            --highlight-selected: #ffd600;
            --highlight-win: #fff9c4;
        }

        body {
            font-family: 'Hiragino Kaku Gothic ProN', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            padding: 10px;
        }

        /* --- Setup Screens --- */
        .setup-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        .setup-content {
            text-align: center;
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            max-width: 400px;
            width: 90%;
        }
        .setup-content h2 { margin-top: 0; color: #333; }
        .setup-content p { color: #666; margin-bottom: 20px; }
        
        .big-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            font-size: 1.1rem;
            border-radius: 8px;
            border: 2px solid #ddd;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        .big-btn:hover { background: #f0f0f0; border-color: #bbb; }
        .big-btn.primary { background: var(--black-color); color: white; border: none; }
        .big-btn.primary:hover { opacity: 0.9; background: var(--black-color); }
        .big-btn.secondary { background: var(--red-color); color: white; border: none; }

        /* --- Game UI --- */
        #debug-panel {
            position: fixed;
            top: 10px; right: 10px; width: 250px;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0; padding: 10px; border-radius: 8px;
            font-family: monospace; font-size: 11px;
            z-index: 1000; pointer-events: none;
            display: none; max-height: 90vh; overflow-y: auto;
        }
        #debug-panel h4 { margin: 0 0 5px 0; border-bottom: 1px solid #0f0; padding-bottom: 3px; }
        .plus { color: #5f5; }
        .minus { color: #f55; }

        #status {
            margin-bottom: 15px; font-weight: bold; font-size: 1.4rem;
            min-height: 1.5em; text-align: center;
        }
        .turn-red { color: var(--red-color); }
        .turn-black { color: var(--black-color); }

        .game-container {
            display: flex; flex-direction: column; gap: 20px; align-items: center;
            opacity: 1; transition: opacity 0.3s;
        }
        .game-container.hidden { display: none; }

        .hand {
            display: flex; gap: 6px; padding: 10px;
            background: #fff; border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 320px; justify-content: center;
            height: 80px; align-items: center;
        }

        .card {
            width: 44px; height: 60px;
            border: 2px solid #333; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.4rem; font-weight: bold;
            background-color: white; box-sizing: border-box;
            transition: transform 0.1s ease-out; position: relative;
        }
        .card.red { color: var(--red-color); border-color: var(--red-color); }
        .card.black { color: var(--black-color); border-color: var(--black-color); }
        .used { opacity: 0.1; pointer-events: none; }

        .movable { box-shadow: 0 0 0 4px var(--highlight-movable); cursor: pointer; }
        .selected {
            background-color: #fffde7;
            border: 3px solid var(--highlight-selected) !important;
            transform: translateY(-8px) scale(1.1) !important;
            z-index: 100 !important;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 10px;
            background-color: var(--board-bg);
            padding: 10px; border-radius: 8px;
        }

        .cell {
            background-color: #fff; width: 100px; height: 100px;
            border-radius: 4px; position: relative;
            display: flex; align-items: center; justify-content: center;
        }
        .win-highlight { background-color: var(--highlight-win) !important; }

        .stack-wrapper {
            position: relative; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            padding-left: 20px; box-sizing: border-box;
        }
        .card-in-cell { position: absolute; box-shadow: -2px 0px 4px rgba(0,0,0,0.2); }
        .pos-single { z-index: 10; transform: translateX(-10px); }
        .pos-top { z-index: 30; transform: translateX(0px); }
        .pos-middle { z-index: 20; transform: translateX(-22px) translateY(2px); }
        .pos-bottom { z-index: 10; transform: translateX(-44px) translateY(4px); }

        .controls { margin-top: 25px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .controls.hidden { display: none; }
        .btn-group { display: flex; gap: 10px; }
        
        button.action-btn {
            padding: 10px 20px; border-radius: 20px; border: none;
            cursor: pointer; font-size: 0.9rem; font-weight: bold;
            transition: opacity 0.2s;
        }
        button.action-btn:active { opacity: 0.7; }
        button.action-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-gray { background: #777; color: white; }
        .btn-outline { background: #eee; color: #333; border: 1px solid #ccc; }
        
        .mode-switch { font-size: 0.9rem; color: #333; display: flex; align-items: center; gap: 5px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="mode-select" class="setup-screen">
        <div class="setup-content">
            <h2>３目カード並べ</h2>
            <p>対戦モードを選択してください</p>
            <button class="big-btn primary" onclick="selectMode(true)">CPU対戦 (ひとり用)</button>
            <button class="big-btn" onclick="selectMode(false)">人間対戦 (ふたり用)</button>
        </div>
    </div>

    <div id="color-select" class="setup-screen" style="display: none;">
        <div class="setup-content">
            <h2>手番の選択</h2>
            <p>先攻(赤)か後攻(黒)を選んでください</p>
            <button class="big-btn secondary" onclick="startGame('red')">赤で開始 (先攻)</button>
            <button class="big-btn primary" onclick="startGame('black')">黒で開始 (後攻)</button>
            <button class="big-btn" onclick="backToMode()" style="margin-top:20px; border:1px solid #ccc; background:#fff;">戻る</button>
        </div>
    </div>

    <div id="debug-panel">
        <h4>CPU Evaluation</h4>
        <div id="debug-content"></div>
    </div>

    <div id="status"></div>

    <div class="game-container hidden" id="game-container">
        <div class="hand" id="hand-red"></div>
        <div class="board" id="board"></div>
        <div class="hand" id="hand-black"></div>
    </div>

    <div class="controls hidden" id="game-controls">
        <div class="btn-group">
            <button class="action-btn btn-outline" onclick="undo()" id="undo-btn">１手戻す (Undo)</button>
            <button class="action-btn btn-gray" onclick="resetToTitle()">タイトルへ戻る</button>
        </div>
        <label class="mode-switch" id="debug-switch-label">
            <input type="checkbox" id="debug-mode" onchange="toggleDebug()"> デバッグ表示
        </label>
    </div>

<script>
    const RANKS = ['K', 'K', 'Q', 'Q', 'J', 'J'];
    const RANK_STRENGTH = { 'K': 3, 'Q': 2, 'J': 1 };
    const LINES = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    
    let boardState = Array.from({length: 9}, () => []);
    let hands = { red: [], black: [] };
    let turn = 'red', winnerInfo = null, sourceSelection = null, isCpuMode = true, isCpuThinking = false, playerColor = 'red', history = []; 

    // --- Setup Flow Functions ---
    
    function selectMode(cpu) {
        isCpuMode = cpu;
        document.getElementById('mode-select').style.display = 'none';
        
        if (cpu) {
            // CPU対戦なら色選択へ
            document.getElementById('color-select').style.display = 'flex';
        } else {
            // 人間対戦なら即開始
            startGame('red'); 
        }
    }

    function backToMode() {
        document.getElementById('color-select').style.display = 'none';
        document.getElementById('mode-select').style.display = 'flex';
    }

    function startGame(selectedColor) {
        document.getElementById('color-select').style.display = 'none';
        document.getElementById('game-container').classList.remove('hidden');
        document.getElementById('game-controls').classList.remove('hidden');
        
        // 人間対戦時はデバッグ表示スイッチを隠す
        document.getElementById('debug-switch-label').style.display = isCpuMode ? 'flex' : 'none';
        
        initGame(selectedColor);
    }

    function resetToTitle() {
        document.getElementById('game-container').classList.add('hidden');
        document.getElementById('game-controls').classList.add('hidden');
        document.getElementById('mode-select').style.display = 'flex';
        document.getElementById('debug-panel').style.display = 'none';
        // デバッグチェックボックスをリセット(OFF)
        document.getElementById('debug-mode').checked = false;
    }

    // --- Game Logic ---

    function toggleDebug() {
        if (!isCpuMode) {
            document.getElementById('debug-panel').style.display = 'none';
            return;
        }
        document.getElementById('debug-panel').style.display = document.getElementById('debug-mode').checked ? 'block' : 'none';
    }

    function saveToHistory() {
        history.push({
            board: JSON.parse(JSON.stringify(boardState)),
            hands: JSON.parse(JSON.stringify(hands)),
            turn: turn,
            winnerInfo: winnerInfo
        });
    }

    function undo() {
        if (history.length === 0 || isCpuThinking) return;

        let steps = 1;
        if (isCpuMode) {
            if (winnerInfo && winnerInfo.color === playerColor) {
                steps = 1;
            } else {
                steps = 2;
            }
        }

        if (history.length < steps) steps = history.length;

        for(let i=0; i<steps; i++) {
            const state = history.pop();
            boardState = state.board;
            hands = state.hands;
            turn = state.turn;
            winnerInfo = state.winnerInfo;
        }
        
        sourceSelection = null;
        render();
    }

    function initGame(selectedColor) {
        playerColor = selectedColor;
        hands.red = RANKS.map((r, i) => ({ rank: r, used: false }));
        hands.black = RANKS.map((r, i) => ({ rank: r, used: false }));
        boardState = Array.from({length: 9}, () => []);
        turn = 'red'; winnerInfo = null; sourceSelection = null; isCpuThinking = false; history = [];
        
        toggleDebug();

        if (isCpuMode && playerColor === 'black') {
            startCpuTurn('red');
        }
        render();
    }

    function checkWin(board) {
        for (let line of LINES) {
            const cards = line.map(idx => board[idx].length > 0 ? board[idx][board[idx].length-1] : null);
            if (cards[0] && cards[1] && cards[2] && cards[0].color === cards[1].color && cards[0].color === cards[2].color) {
                return { color: cards[0].color, line: line };
            }
        }
        return null;
    }

    function onHandClick(color, index) {
        if (winnerInfo || isCpuThinking || (isCpuMode && color !== playerColor) || color !== turn || hands[color][index].used) return;
        sourceSelection = (sourceSelection && sourceSelection.type==='hand' && sourceSelection.index===index) ? null : { type: 'hand', color, index, rank: hands[color][index].rank };
        render();
    }

    function onBoardClick(cellIndex) {
        if (winnerInfo || isCpuThinking) return;
        const top = boardState[cellIndex][boardState[cellIndex].length-1];
        
        if (top && top.color === turn && !(isCpuMode && turn !== playerColor)) {
            sourceSelection = (!sourceSelection || sourceSelection.type !== 'board' || sourceSelection.cellIndex !== cellIndex) ? { type: 'board', cellIndex, color: turn, rank: top.rank } : null;
            render();
            return;
        }
        
        if (sourceSelection && isValidMove(boardState, sourceSelection, cellIndex)) {
            saveToHistory();
            executeMove(sourceSelection, cellIndex);
        }
    }

    function isValidMove(board, src, targetIndex) {
        if (src.type === 'board' && src.cellIndex === targetIndex) return false;
        const targetTop = board[targetIndex][board[targetIndex].length-1];
        if (targetTop) {
            if (targetTop.color === src.color) return false;
            if (RANK_STRENGTH[src.rank] <= RANK_STRENGTH[targetTop.rank]) return false;
        }
        return true;
    }

    function executeMove(src, targetIndex) {
        const card = { color: src.color, rank: src.rank };
        if (src.type === 'hand') hands[src.color][src.index].used = true;
        else boardState[src.cellIndex].pop();
        boardState[targetIndex].push(card);
        sourceSelection = null;
        winnerInfo = checkWin(boardState);
        turn = turn === 'red' ? 'black' : 'red';
        render();
        if (!winnerInfo && isCpuMode && turn !== playerColor) startCpuTurn(turn);
    }

    function startCpuTurn(cpuColor) {
        isCpuThinking = true; render();
        setTimeout(() => {
            const result = calculateBestMove(cpuColor);
            isCpuThinking = false;
            if (result) {
                if (result.surrender) { winnerInfo = { color: playerColor, line: [], surrender: true }; render(); return; }
                updateDebugView(result.details); saveToHistory(); executeMove(result.source, result.targetIndex);
            }
        }, 500);
    }

    function calculateBestMove(myColor) {
        const oppColor = myColor === 'red' ? 'black' : 'red';
        const myHand = hands[myColor];
        const oppHand = hands[oppColor];
        
        const moves = getAllValidMoves(boardState, myColor, myHand);
        if (moves.length === 0) return { surrender: true };

        let bestScore = -Infinity;
        let bestMoves = [];

        for (let move of moves) {
            let score = 0;
            let plus = {}, minus = {};

            const simBoard = JSON.parse(JSON.stringify(boardState));
            const simMyHand = JSON.parse(JSON.stringify(myHand));
            
            if (move.source.type === 'board') {
                simBoard[move.source.cellIndex].pop();
            } else {
                simMyHand[move.source.index].used = true;
            }
            const movedCard = { color: myColor, rank: move.source.rank };
            simBoard[move.targetIndex].push(movedCard);

            const exposedWin = checkWin(simBoard);
            if (exposedWin && exposedWin.color === oppColor) {
                score = -99999; 
                minus["自爆(露出)"] = -99999;
            } else {
                if (checkWin(simBoard)?.color === myColor) {
                    score += 2000; plus["勝利"] = 2000;
                }

                const centerTop = simBoard[4].length > 0 ? simBoard[4][simBoard[4].length-1] : null;
                if (centerTop && centerTop.color === myColor) {
                    if (centerTop.rank === 'K') { score += 100; plus["中央K確保"] = 100; }
                    else { score += 50; plus["中央確保"] = 50; }
                }

                let qkCount = 0, qjCount = 0;
                for(let i=0; i<9; i++) {
                    const stack = simBoard[i];
                    if (stack.length >= 2) {
                        const top = stack[stack.length-1];
                        const below = stack[stack.length-2];
                        if (top.color === myColor) {
                            if (top.rank === 'K' && below.rank === 'Q') qkCount++;
                            if (top.rank === 'Q' && below.rank === 'J') qjCount++;
                        }
                    }
                }
                if (qkCount > 0) { score += qkCount * 30; plus[`Q->K上乗せ x${qkCount}`] = qkCount * 30; }
                if (qjCount > 0) { score += qjCount * 10; plus[`J->Q上乗せ x${qjCount}`] = qjCount * 10; }

                const myReach = analyzeReach(simBoard, myColor);
                if (myReach.hasDoubleK) { score += 500; plus["Wリーチ(K)"] = 500; }
                else if (myReach.doubleReach) { score += 100; plus["Wリーチ"] = 100; }
                else if (myReach.reachCount === 1) { score += 20; plus["リーチ"] = 20; }

                const oppKPinnedCount = countPinnedKs(simBoard, oppColor);
                if (oppKPinnedCount > 0) {
                    let s = 30 * oppKPinnedCount;
                    score += s; plus[`相手Kピン x${oppKPinnedCount}`] = s;
                }

                if (simMyHand.some(c => !c.used && c.rank === 'K')) {
                    score += 20; plus["手札にK"] = 20;
                }

                const oppMoves = getAllValidMoves(simBoard, oppColor, oppHand);
                let canBeDefeated = false;
                let riskCenterK = false, riskCenter = false;
                let riskStackKQ = 0, riskStackQJ = 0;
                let riskReach = false, riskDouble = false, riskDoubleK = false;

                for (let om of oppMoves) {
                    const s2 = JSON.parse(JSON.stringify(simBoard));
                    if (om.source.type === 'board') s2[om.source.cellIndex].pop();
                    s2[om.targetIndex].push({ color: oppColor, rank: om.source.rank });

                    if (checkWin(s2)?.color === oppColor) {
                        canBeDefeated = true; break; 
                    }
                    const cTop = s2[4].length ? s2[4][s2[4].length-1] : null;
                    if (cTop && cTop.color === oppColor) {
                        if (cTop.rank === 'K') riskCenterK = true;
                        else riskCenter = true;
                    }
                    const targetStack = s2[om.targetIndex];
                    if (targetStack.length >= 2) {
                        const t = targetStack[targetStack.length-1];
                        const b = targetStack[targetStack.length-2];
                        if (t.color === oppColor) {
                            if (t.rank === 'K' && b.rank === 'Q') riskStackKQ++;
                            if (t.rank === 'Q' && b.rank === 'J') riskStackQJ++;
                        }
                    }
                    const rInfo = analyzeReach(s2, oppColor);
                    if (rInfo.hasDoubleK) riskDoubleK = true;
                    else if (rInfo.doubleReach) riskDouble = true;
                    else if (rInfo.reachCount >= 1) riskReach = true;
                }

                if (canBeDefeated) { score -= 1000; minus["次手敗北"] = -1000; }
                else {
                    let hasEnemyCenterK = false;
                    const curCenter = simBoard[4].length ? simBoard[4][simBoard[4].length-1] : null;
                    if (curCenter && curCenter.color === oppColor) {
                        if (curCenter.rank === 'K') { 
                            score -= 100; minus["敵中央K"] = -100; 
                            hasEnemyCenterK = true;
                        }
                        else { score -= 50; minus["敵中央"] = -50; }
                    }

                    if (!hasEnemyCenterK) {
                        if (riskCenterK) { score -= 100; minus["敵中央K可"] = -100; }
                        else if (riskCenter) { score -= 50; minus["敵中央可"] = -50; }
                    }

                    let oppQkCount = 0, oppQjCount = 0;
                    for(let i=0; i<9; i++) {
                        const st = simBoard[i];
                        if(st.length>=2) {
                            const t = st[st.length-1];
                            const b = st[st.length-2];
                            if(t.color === oppColor) {
                                if(t.rank==='K' && b.rank==='Q') oppQkCount++;
                                if(t.rank==='Q' && b.rank==='J') oppQjCount++;
                            }
                        }
                    }
                    if(oppQkCount > 0) { score -= oppQkCount * 30; minus[`敵Q->K済 x${oppQkCount}`] = -oppQkCount * 30; }
                    if(oppQjCount > 0) { score -= oppQjCount * 10; minus[`敵J->Q済 x${oppQjCount}`] = -oppQjCount * 10; }

                    const myKPinnedCount = countPinnedKs(simBoard, myColor);
                    if (myKPinnedCount > 0) { 
                        score -= (30 * myKPinnedCount); 
                        minus[`自分Kピン x${myKPinnedCount}`] = -30 * myKPinnedCount; 
                    }

                    const validHand = simMyHand.filter(c => !c.used);
                    if (validHand.length > 0 && validHand.every(c => c.rank === 'J')) {
                        score -= 20; minus["手札Jのみ"] = -20;
                    }

                    if (riskStackKQ > 0) { score -= 30; minus["敵Q->K可"] = -30; }
                    if (riskStackQJ > 0) { score -= 10; minus["敵J->Q可"] = -10; }
                    if (riskDoubleK) { score -= 500; minus["敵WリーチK可"] = -500; }
                    else if (riskDouble) { score -= 100; minus["敵Wリーチ可"] = -100; }
                    else if (riskReach) { score -= 20; minus["敵リーチ可"] = -20; }
                }
            }

            move.details = { total: score, plus, minus };
            if (score > bestScore) {
                bestScore = score;
                bestMoves = [move];
            } else if (score === bestScore) {
                bestMoves.push(move);
            }
        }
        return bestMoves[Math.floor(Math.random() * bestMoves.length)];
    }

    function getAllValidMoves(board, color, hand) {
        const moves = [];
        hand.forEach((c, i) => { 
            if(!c.used) {
                for(let t=0; t<9; t++) {
                    if(isValidMove(board, {type:'hand', color, index:i, rank:c.rank}, t)) {
                        moves.push({source:{type:'hand', color, index:i, rank:c.rank}, targetIndex:t});
                    }
                }
            }
        });
        board.forEach((s, i) => { 
            if(s.length > 0 && s[s.length-1].color === color) {
                const rank = s[s.length-1].rank;
                for(let t=0; t<9; t++) {
                    if(isValidMove(board, {type:'board', cellIndex:i, color, rank}, t)) {
                        moves.push({source:{type:'board', cellIndex:i, color, rank}, targetIndex:t});
                    }
                }
            }
        });
        return moves;
    }

    function analyzeReach(board, color) {
        let reachLines = [];
        for (let line of LINES) {
            let myCards = [];
            let emptyIdx = -1;
            let otherFound = false;
            line.forEach(idx => {
                const top = board[idx].length ? board[idx][board[idx].length-1] : null;
                if (top) {
                    if (top.color === color) myCards.push({rank: top.rank, cellIndex: idx});
                    else otherFound = true;
                } else {
                    emptyIdx = idx;
                }
            });
            if (myCards.length === 2 && emptyIdx !== -1 && !otherFound) {
                reachLines.push({line, myCards, emptyIdx});
            }
        }

        let hasDoubleK = false;
        if (reachLines.length >= 2) {
            const cardCounts = {};
            reachLines.forEach(rl => {
                rl.myCards.forEach(c => {
                    cardCounts[c.cellIndex] = (cardCounts[c.cellIndex] || 0) + 1;
                });
            });
            const pivotIndex = Object.keys(cardCounts).find(idx => cardCounts[idx] >= 2);
            if (pivotIndex !== undefined) {
                const pivotCard = board[pivotIndex][board[pivotIndex].length-1];
                if (pivotCard && pivotCard.rank === 'K' && pivotCard.color === color) hasDoubleK = true;
            }
        }
        return { reachCount: reachLines.length, doubleReach: reachLines.length >= 2, hasDoubleK: hasDoubleK };
    }

    function countPinnedKs(board, targetKColor) {
        let pinnedCount = 0;
        const opponentColor = targetKColor === 'red' ? 'black' : 'red';
        const currentOpponentReach = analyzeReach(board, opponentColor).reachCount;
        
        board.forEach((stack, idx) => {
            if (stack.length === 0) return;
            const top = stack[stack.length-1];
            if (top.color === targetKColor && top.rank === 'K') {
                const vBoard = JSON.parse(JSON.stringify(board));
                vBoard[idx].pop();
                const winInfo = checkWin(vBoard);
                if (winInfo && winInfo.color === opponentColor) {
                    pinnedCount++;
                    return;
                }
                const newOpponentReach = analyzeReach(vBoard, opponentColor).reachCount;
                if (newOpponentReach > currentOpponentReach) {
                    pinnedCount++;
                }
            }
        });
        return pinnedCount;
    }

    function updateDebugView(d) {
        let h = `<div>Total: ${d.total}</div><br><div class="plus">【プラス要素】</div>`;
        for(let k in d.plus) h += `<div class="plus">・${k}: +${d.plus[k]}</div>`;
        h += `<br><div class="minus">【マイナス要素】</div>`;
        for(let k in d.minus) h += `<div class="minus">・${k}: ${d.minus[k]}</div>`;
        document.getElementById('debug-content').innerHTML = h;
    }

    function render() {
        const st = document.getElementById('status');
        if (winnerInfo) {
            st.innerText = (winnerInfo.color==='red'?'赤':'黒') + (winnerInfo.surrender?"(降参)":"") + "の勝利！";
            st.className = 'turn-' + winnerInfo.color;
        } else {
            if (isCpuMode) {
                st.innerText = isCpuThinking ? "CPU思考中..." : (turn !== playerColor ? "CPUの番" : "あなたの手番");
            } else {
                st.innerText = (turn === 'red' ? "赤の手番" : "黒の手番");
            }
            st.className = 'turn-' + turn;
        }

        const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
        boardState.forEach((stack, i) => {
            const cell = document.createElement('div');
            cell.className = 'cell' + (winnerInfo?.line.includes(i) ? ' win-highlight' : '');
            cell.onclick = () => onBoardClick(i);
            if (stack.length > 0) {
                const wrapper = document.createElement('div'); wrapper.className = 'stack-wrapper';
                stack.forEach((card, idx) => {
                    const cEl = document.createElement('div');
                    let posClass = stack.length === 1 ? "pos-single" : (stack.length === 2 ? (idx === 0 ? "pos-middle" : "pos-top") : (idx === 0 ? "pos-bottom" : (idx === 1 ? "pos-middle" : "pos-top")));
                    cEl.className = `card ${card.color} card-in-cell ${posClass}`;
                    cEl.innerText = card.rank;
                    if (idx === stack.length-1) {
                        if (!winnerInfo && !sourceSelection && turn === card.color && !(isCpuMode && turn !== playerColor)) cEl.classList.add('movable');
                        if (sourceSelection?.type === 'board' && sourceSelection.cellIndex === i) cEl.classList.add('selected');
                    }
                    wrapper.appendChild(cEl);
                });
                cell.appendChild(wrapper);
            }
            boardEl.appendChild(cell);
        });

        const drawH = (id, color) => {
            const el = document.getElementById(id); el.innerHTML = '';
            hands[color].forEach((h, i) => {
                const c = document.createElement('div');
                c.className = `card ${color}` + (h.used ? ' used' : '');
                c.innerText = h.rank;
                if (!h.used && !(isCpuMode && color !== playerColor)) {
                    c.onclick = (e) => { e.stopPropagation(); onHandClick(color, i); };
                    if (sourceSelection?.type === 'hand' && sourceSelection.index === i && sourceSelection.color === color) c.classList.add('selected');
                    else if (!winnerInfo && turn === color && !sourceSelection) c.classList.add('movable');
                }
                el.appendChild(c);
            });
        };
        drawH('hand-red', 'red'); drawH('hand-black', 'black');
        document.getElementById('undo-btn').disabled = history.length === 0 || isCpuThinking;
    }
</script>
</body>
</html>